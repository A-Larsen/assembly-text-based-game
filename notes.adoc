== Determining string length of user input
I think I need to fill `buffer` with zeros first and then determine its
length after the read syscall

== database ?
Maybe just save to raw binary file and read it later? Create vriables in `.data`
that are ids for the position in the data. You could then create similar
versions of that data in `.bss` that get read into memory on a read file. Data
is writen into a file, first it writes the 8-bit id, then it writes the 8-bit
length of the data, and then the data. I'm going to need a way to have dynamic
memory, maybe using `extern malloc` ? Or allocating you own memory? Seems a bit
in depth.

- https://stackoverflow.com/questions/5561022/how-to-dynamically-allocate-memory-for-an-array-in-assembly-8086-using-nasm[memory allocation]
- https://baptiste-wicht.com/posts/2011/11/dynamic-memory-allocation-intel-assembly-linux.html[memory allocation intel assemly linux]
 
== Writing to a file?
open file wiht sys_open. write to file descriptor with sys_write?

== Stack frame
 I thinking pushing sometimes causes segfaults because it unaligns the stack,
 making it not 16-byte aligned. It seems that is the case, doing another push
 seems to realign the stack

== Malloc?
https://stackoverflow.com/questions/48672864/how-to-use-malloc-and-free-in-64-bit-nasm
